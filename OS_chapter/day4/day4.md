# 메모리

### 메모리 계층
- 레지스터
    : CPU 안에서 연산을 위한 저장소를 제공 하고, CPU 안에 내장되어 있어 속도가 굉장히 빠르지만 용량은 크지 않다.
- 캐시 (L1/L2)
    : CPU 와 주 기억장치 사이에서 중간 저장소 역할을 한다. 캐시는 CPU 에 가장 근접해 있는 메모리로 레지스터와 주 기억장치 사이에 데이터 이동이 있을 경우 속도를 보완하는 역할을 한다. 캐시는 자주 사용되거나 이미 사용된 데이터를 캐시에 저장함으로써 주 기억장치에서 데이터를 가져오는 것 보다 캐시에 접근해 데이터를 가져오는 것이 훨씬 빠르다.
- 메인 메모리(주 기억장치) (RAM)
    : 운영체제와 프로세스들이 올라가는 공간
- 보조 기억장치
    : 크고 작은 파일들을 저장하기 위한 공간

휘발성 메모리 : 레지스터, 캐시, 메인 메모리(주 기억장치) -> 용량이 적고 속도가 빠르지만 비싸다
비 휘발성 메모리 : 보조 기억장치 -> 비교적 용량이 크고 속도가 느리지만 저렴하다

### 메모리 할당 방식
- 가변 분할 방식
    : 프로세스의 크기에 따라 가변적으로 메모리를 나누는 방식. 크면 큰대로 작으면 작은대로
      연속 메모리 할당 (세그먼테이션)

    외부 단편화 : 가변적으로 프로세스의 크기 만큼 할당했던 메모리 공간이 프로세스가 종료 되고 비게 되었을 때 이전에 할당했던 프로세스의 크기보다 더 큰
               프로세스가 실행되어야 할 때 실행될 공간이 없는 경우 문제가 될 수 있다. (프로세스가 남아 있는 메모리 할당 공간보다 큰 경우)
               이때문에 빈 공간들을 합치는 작업인 조각 모음 작업을 실행해야하는데 이 작업은 시스템에 상당한 부담을 주는 작업이기에 빈번하게 실행되면 안된다.

- 고정 분할 방식
    : 고정된 크기로 메모리를 나누어 놓은 다음에 나누어진 메모리를 프로그램 크기 만큼 할당해 주는 방식
      비 연속 메모리 할당 (페이징)

### 스와핑 (가변)
    실행중인 프로세스는 주 기억장치에 머룰러 있고, 실행중이 아닌 프로세스는 보조 기억장치에서 준비 또는 대기 하는 공간인 스왑영역에 위치한다.
    운영체제가 프로세스를 실행하기위해 스왑영역에서 주 기억장치로 (스왑 인), 주 기억장치에서 스왑영역으로 내보내기 위해 (스왑 아웃) 스와핑 작업을 실행한다.

    스왑핑을 이용하면 메모리의 총 용량보다 더 많은 프로세스들을 동시에 처리 가능하게 된다.


### 가상 메모리
    권장 메모리 용량이 메인메모리의 전체 용량과 같은 게임을 실행해도 잘 실행이 된다. -> 이것을 가능하게 해 주는 것이 가상메모리

### 페이징
    메모리 공간을 일정한 크키로 나누어서 다루는디 이 공간을 페이지 라고 한다.
    여기에 프로세스들을 불연속적으로 올린다면 세그멘테이션에서 발생할 수 있는 외부 단편화도 방지할 수 있다.
    하지만 외부 단편화의 반대인 페이지 안에서 공간이 남는 내부 단편화가 일어날 수도 있다.

    운영체제는 가상 메모리를 위해 논리주소 공간과 물리주소 공간을 일정한 크기로 나누어서 다룬다.
    페이징을 사용하는 시스템에서는 CPU 가 논리주소를 통해 메모리에 접근하고 운영체제가 이를 물리주소로 변환하여 실제 메모리에 올리는 방식으로 
    프로세스를 실행 시킨다.

    프로세스 실행을 위해 사용하는 논리주소 공간이 메모리의 실제 크기보다 크기때문에 부족한 공간을 스와핑을 통해 보조 기억장치의 도움을 받는다.
    이와 같은 방식을 통해 실제 메모리 공간보다 더 큰 프로세스를 실행 할 수 있는 것이다.

    페이지 테이블
        : 논리 주소에 맞는 물리 주소를 찾아 갈 수 있도록 각 프로세스 마다 페이지 테이블 을 가질 수 있도록한다
          페이지 번호와 프레임 번호를 짝지어주는 표
          각 프로세스들의 페이지 테이블은 메모리에 적재
          CPU 내에는 각 프로세스들의 페이지 테이블이 적재된 주소를 가리키는 페이지 테이블 베이스 레지스터를 가지고 있어 프로세스들이
          물리 공간에 불연속적으로 배치 되어있다 해도 찾아 갈 수 있다.
        
        - 페이지 테이블 엔트리 : 페이지 테이블의 각 행
            접근 비트 : 페이지가 메모리에 올라온 후 데이터에 접근이 있었는지 
                - 메모리에 읽기나 실행작업을 했다면 1로 바뀌게 된다.
            변경 비트 : 페이지가 메모리에 올라온 후 데이터에 변경이 있었는지 
                - 메모리에 쓰기 작업이 있었다면 1로 바뀌게된다.
            유효 비트 : 페이지가 어디에 있는지 
                - 유효 비트가 0이라면 페이지가 스왑 영역에 있고, 1이라면 물리 메모리에 있다.
                  만약 CPU 가 유효 비트가 0인 메모리에 올라가있지 않은 페이지로 접근하려 하면 페이지 폴트라는 예외가 발생한다.
                  페이지 폴트가 발새하면 프로세스를 바로 실행할 수 없다는 의미이기 때문에 추가적인 액션이 있을것이다.
            보호 비트 : 페이지가에 대한 읽기, 쓰기, 실행 권한이 어떻게 되는지 
                - 보호 비트는 3개의 비트로 나누어져 있다. 권한 비트라고도 한다.
                  각각 읽기, 쓰기, 실행 권한을 나타낸다. ex 100 - 읽기 권한, 111 - 모든 권한

    논리 주소 공간 
        : 사용자와 프로세스가 참조하는 공간으로 실제 메인 메모리 크기보다 더 큰 공간 (보조 기억장치의 크기를 지원받아 크기를 키운 것)
          논리주소 공간의 조각 - 페이지
    물리 주소 공간
        : 실제 메인 메모리 공간을 뜻한다.
          물리주소 공간의 조각 - 프레임

### 페이지드 세그멘테이션
    가변분할 방식(세그멘테이션)과 고정 분할 방식(페이징)을 혼합한 가상 메모리 관리 방식
    운영체제가 세그멘테이션 테이블을 관리
    CPU 가 논리주소에 접근을 요청하면 운영체제가 세그멘테이션 테이블을 통해 몇번에 접근할지 확인하고 권한을 확인해서 차단시키기도 하고 연결시키기도 한다.

### 요구 페이징
    CPU 가 특정 페이지에 접근하는 명령어를 실행했을 떄, 해당 페이지가 스왑 영역에 있어서 당장 실행시킬 수 없는 상태일 경우에는 '페이지 폴트' 예외가 발생한다.
    페이지 폴트가 발생하게 되면 운영체제는 해당 페이지를 스왑영역에서 메모리로 옮기고 유효비트는 1로 변경하는 작업을 처리해야 하고 그 다음 CPU 가 명령어를 실행할 수 있도록 해주는것이 순서이다.

    실행할 모든 프로세스를 메모리에 올려두는 것은 시스템에 부담이 될 수 있는 만큼 처음부터 모든 페이지를 메모리에 적재하디 않고 당장 필요한 페이지만을 메모리에 우선 적재하는 방법을 가리켜 '요구 페이징' 이라 한다.

    요구 페이징 시스템이 안정적으로 돌아가기 위해서는 안정적인 페이지 교체 및 프레임 할달 기법이 필요하다.

### 페이지 교체
    페이지 폴트가 발생하면 페이지 교체가 이루어짐
    메인 메모리가 꽉 차 있는 상태에서 스왑 영역에 있는 페이지를 메인 메모리로 이동시켜야 하는 경우가 있는데 이때
    메인 메모리에 빈 공간을 만들어주기 위해 메인 메모리에 있는 페이지 중 어떠한 페이지를 스왑 영역으로 보낼 것인지를 결정하고 그것을 처리하는 작업

    - 선입선출
        : 메모리에 들어온 시간이 가장 오래된 페이지를 내보내는 방식
    - 최적 페이지 교체
        : CPU 에 의해 참조되는 횟수를 고래해서 자주 사용될 페이지를 남겨두고 덜 사용될 페이지를 교체하는것 (이론적으로만 존재)
    - LRU(Least Recently Used)
        : 최근 사용빈도가 가장 적은 페이지를 교체하는 방법

### 스래싱(thrashing)
    이 모든 것의 근본적인 이유는 메모리 공간의 부족, 가상 메모리 관점에서 보면 즉 프레임 부족이다.
    프레임이 부족하면 페이지 폴트가 자주 발생한다.
    페이지 폴트가 발생하면 잦은 스와핑 작업으로 인해 CPU 사용률이 떨어지게 된다.

    CPU 사용률이 떨어지면 운영체제는 더 많은 프로세스를 메모리에 올리려 하고,
    이는 더 잦은 페이지 폴트로 이어져 악순환에 빠지게 된다.
    이러한 문제를 스래싱이라한다.

    가장 좋은 방법은 메인 메모리가 큰게 좋지만 성능저하를 막기위해서는 운영체제가 잘 관리하는것이 중요하다.

# 스래싱 (thrashing)
동시에 실행되는 프로세스의 수가 늘어나게 되면 어느 순간부터 page fault 가 자주 발생하게 되고
page fault 가 진행 될때는 cpu 가 아무것도 하지 않아서 cpu 사용률이 떨어지게 된다.

이 때, 운영체제는 cpu 사용률이 떨어진것만 보고 cpu 가 놀고 있다고 판단하여 더 많은 프로세스들을 메모리에 올리려하고
이렇게 되면 page fault 가 더 자주 발생하게 되고 다시 또 cpu 사용률이 떨어지고 더 많은 프로세스들을 메모리에 올리려하고 하는 
악순환이 발생된다.

이러한 현상을 스래싱이라 한다.

# 워킹셋 (Working Set)
운영체제가 메모리를 관리 할 때 지역성을 활용하는 것을 말한다. 운영체제는 프로세스가 필요한 전체 메모리를 할당하는 것이 아니고 일부만 할당하는데, 지역성을 잘 고려해서 가장 많이 사용하는 페이지를 미리 working set 으로 구별하고 그 working set 을 메모리에 할당한다.

이 때 working set 의 구간을 working set window 라 한다. working set window 의 값은 working set 을 이루는 페이지의 갯수에 따라 달라진다. 페이지 갯수가 3개 이면 working set window 는 3이 된다

전체 메모리 참조가 아니라 지정한 구간만큼의 내용만을 working set window 로 정의하고 이를 계속 이동해가면서 working set 내용을 변경시키는 구조이다.
이렇게 하면 working set 에는 현재 프로세스가 실행될 때 필요한 지역성에 해당하는 페아자들만 들어있기 때문에 page fault 를 최소화 할 수 있다.

page fault 는 working set window 가 이동할때만 발생한다.